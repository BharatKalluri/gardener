import os
from dataclasses import dataclass
from typing import Set, Dict, Optional

# TODO: This needs to come from config
GITHUB_PAGES = True


@dataclass
class NoteMetadata:
    back_links: Set[str]
    note_name: str
    relative_path_without_ext: str
    wiki_links: Set[str]
    complete_path: str

    HEADER: str = '[//begin]: # "Autogenerated link references for markdown compatibility"'
    FOOTER: str = '[//end]: # "Autogenerated link references for markdown compatibility"'

    # TODO: Refactor this method, extract all the sub methods into different class methods.
    def generate_reference_block(self, note_to_metadata_map: Dict[str, 'NoteMetadata']) -> str:
        reference_block_lines = [self.HEADER]

        # Populating back links
        if self.back_links:
            reference_block_lines.append(os.linesep)
            reference_block_lines.append("#### Back links")
            for back_link in self.back_links:
                back_link_metadata = note_to_metadata_map.get(back_link)
                if back_link_metadata:
                    if back_link_metadata.note_name.lower() == 'readme' and GITHUB_PAGES:
                        back_link_metadata.relative_path_without_ext = \
                            back_link_metadata.relative_path_without_ext.replace("readme", "")
                    reference_block_lines.append(
                        f"- [{back_link_metadata.note_name}]({back_link_metadata.relative_path_without_ext})")
            reference_block_lines.append(os.linesep)

        # Populating wiki links
        for link in self.wiki_links:
            linked_note_metadata: Optional[NoteMetadata] = note_to_metadata_map.get(link)
            if linked_note_metadata:
                reference_block_lines.append(
                    f'[{linked_note_metadata.note_name}]: {linked_note_metadata.relative_path_without_ext}'
                    f' "{linked_note_metadata.note_name}"')

        reference_block_lines.append(self.FOOTER)
        return os.linesep.join(reference_block_lines)

    @staticmethod
    def get_file_contents_without_reference_block(file_contents: str):
        header_line_no = None
        footer_line_no = None
        lines_in_file = file_contents.split(os.linesep)
        total_line_count = len(lines_in_file)
        for i in range(len(lines_in_file)):
            line_contents = lines_in_file[i]
            if NoteMetadata.HEADER in line_contents:
                header_line_no = i
            if NoteMetadata.FOOTER in line_contents:
                footer_line_no = i

        contents_till_header = lines_in_file[:header_line_no] if header_line_no else lines_in_file[:total_line_count]
        contents_after_footer = lines_in_file[(footer_line_no + 1):] if footer_line_no else lines_in_file[
                                                                                            total_line_count:]
        final_file_contents = os.linesep.join(contents_till_header + contents_after_footer)
        return final_file_contents

    def refresh_reference_block_for_note(self, note_to_metadata_map: Dict[str, 'NoteMetadata']):
        with open(self.complete_path, "r") as readable_file:
            file_contents = readable_file.read()
            cleared_file_contents = self.get_file_contents_without_reference_block(file_contents)
            ref_text = self.generate_reference_block(note_to_metadata_map)
            with open(self.complete_path, "w") as writeable_file:
                writeable_file.write(cleared_file_contents.strip() + (os.linesep * 3) + ref_text)
